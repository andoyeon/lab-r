---
title: "Movie Score Prediction"
author: "AN DoYeon"
date: '2019 10 28 '
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. 데이터 준비, 확인
```{r}
USA_movie <- read.csv("USA_movie.csv")
movie <- USA_movie
str(movie)
summary(movie)
```

## 2. 데이터 전처리
###    1) 결측치 처리 => 평균으로 대치
```{r}
sum(is.na(movie))
1334 / (3807*28)
```

```{r}
avg_num_critic_for_reviews <- mean(movie$num_critic_for_reviews, na.rm = T)
movie$num_critic_for_reviews <- ifelse(is.na(movie$num_critic_for_reviews),
                                      avg_num_critic_for_reviews,movie$num_critic_for_reviews)

avg_duration <- mean(movie$duration, na.rm = T)
movie$duration <- ifelse(is.na(movie$duration), avg_duration, movie$duration)

avg_director_facebook_likes <- mean(movie$director_facebook_likes, na.rm = T)
movie$director_facebook_likes <- ifelse(is.na(movie$director_facebook_likes),
                                        avg_director_facebook_likes, movie$director_facebook_likes)

avg_actor_3_facebook_likes <- mean(movie$actor_3_facebook_likes, na.rm = T)                                      
movie$actor_3_facebook_likes <- ifelse(is.na(movie$actor_3_facebook_likes),
                                       avg_actor_3_facebook_likes, movie$actor_3_facebook_likes)

avg_actor_1_facebook_likes <- mean(movie$actor_1_facebook_likes, na.rm = T)
movie$actor_1_facebook_likes <- ifelse(is.na(movie$actor_1_facebook_likes),
                                       avg_actor_1_facebook_likes, movie$actor_1_facebook_likes)

avg_gross <- mean(movie$gross, na.rm = T)
movie$gross <- ifelse(is.na(movie$gross), avg_gross, movie$gross)

avg_facenumber_in_poster <- mean(movie$facenumber_in_poster, na.rm = T)
movie$facenumber_in_poster <- ifelse(is.na(movie$facenumber_in_poster),
                                     avg_facenumber_in_poster, movie$facenumber_in_poster)

avg_num_user_for_reviews <- mean(movie$num_user_for_reviews, na.rm = T)
movie$num_user_for_reviews <- ifelse(is.na(movie$num_user_for_reviews), 
                                     avg_num_user_for_reviews, movie$num_user_for_reviews)

avg_budget <- mean(movie$budget, na.rm = T)
movie$budget <- ifelse(is.na(movie$budget), avg_budget, movie$budget)


avg_actor_2_facebook_likes <- mean(movie$actor_2_facebook_likes, na.rm = T)
movie$actor_2_facebook_likes <- ifelse(is.na(movie$actor_2_facebook_likes), 
                                       avg_actor_2_facebook_likes, movie$actor_2_facebook_likes)

avg_aspect_ratio <- mean(movie$aspect_ratio, na.rm = T)
movie$aspect_ratio <- ifelse(is.na(movie$aspect_ratio), avg_aspect_ratio, movie$aspect_ratio)
```

## 3. 상관 관계 파악
###    1) IMDB 분포도
```{r}
library(ggplot2)
ggplot(data = movie, mapping = aes(x = imdb_score)) +
  geom_bar(fill = "#FFCC00") +
  theme_light()
```

###    2) Heatmap 
변수들 간의 상관 관계 파악 - heatmap으로 시각화

숫자형이고, 의미 있는 변수들로만 이루어진 데이터 프레임 생성
```{r}
movie_data <- movie[c("num_critic_for_reviews", "duration", "director_facebook_likes",
                     "actor_3_facebook_likes", "actor_1_facebook_likes", "gross", "num_voted_users",
                     "cast_total_facebook_likes", "facenumber_in_poster", "num_user_for_reviews",
                     "budget", "actor_2_facebook_likes","imdb_score", "movie_facebook_likes")]
```

heatmap
```{r}
cormat <- round(cor(movie_data), 2)
head(cormat)

search()

library(reshape2)
melted_cormat <- melt(cormat)
head(melted_cormat)

# Get lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Get upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}


reorder_cormat <- function(cormat){
  # Use correlation between variables as distance
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
}

# Reorder the correlation matrix
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "black", high = "#FFCC00", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Movie\nCorrelation") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 10, hjust = 1),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  coord_fixed()
# Print the heatmap
print(ggheatmap)
```


###    3) IMDB score와 관련 있는 변수들로 이루어진 데이터 프레임 생성
```{r}
movie <- movie_data[c("duration", "director_facebook_likes", "actor_1_facebook_likes",
                         "cast_total_facebook_likes", "actor_2_facebook_likes","imdb_score",
                         "movie_facebook_likes")]
```



## 4. 머신러닝
###    1) 다중 선형 회귀(Multiple Linear Regression)
```{r}
# 다중 선형 회귀
# 종속 변수 - imdb_score
str(movie)
summary(movie)

# imdb_score 분포도
hist(movie$imdb_score, col = "#FFCC00", border = "white")

# 상관 행렬
library(psych)
pairs.panels(movie)


# 회귀 모델
lm_movie <- lm(formula = imdb_score ~ ., data = movie)
lm_movie

plot(imdb_score ~ ., data = movie)
plot(lm_movie)  # 모델이 적합한지

# 통계적으로 유의한지 여부 확인
summary(lm_movie)   # 모두 유의한 변수 # R-squared: 0.1353

# 회귀 트리
library(rpart)

sample_count <- round(nrow(movie)) * 0.75
set.seed(123)
sample_rows <- sample(nrow(movie), sample_count)

train <- movie[sample_rows, ]
test <- movie[-sample_rows, ]

# rpart를 이용해 학습시키기
movie_rpart <- rpart(formula = imdb_score ~ ., data = train)
movie_rpart

# 회귀트리 시각화
library(rpart.plot)
rpart.plot(x = movie_rpart, digits = 3, cex = 0.8, fallen.leaves = T, type = 5)

# 모델 평가
movie_predict <- predict(movie_rpart, test)
summary(movie_predict)
summary(test$imdb_score)

# 모델 성능 평가
# 1) 상관 계수
cor(movie_predict, test$imdb_score) # 0.449
# 2) MAE: 평균 절대 오차
MAE <- function(actual, predict) {
  return(mean(abs(actual - predict)))
}
MAE(actual = test$imdb_score, predict = movie_predict)  # 0.761

```


모델 트리
```{r}
# 모델 성능 향상
# 모델 트리
library(Cubist)
movie_cubist <- cubist(x = train[-6], y = train$imdb_score)
movie_cubist


# 모델 트리 성능 테스트
movie_predict2 <- predict(movie_cubist, test)
head(movie_predict2)
summary(movie_predict2)
summary(test$imdb_score)

# 모델 성능 평가
# 1) 상관 계수
cor(movie_predict2, test$imdb_score)  # 0.469
# 2) MAE
MAE(actual = test$imdb_score, predict = movie_predict2) # 0.736
# => 성능 좋아짐
```


###    2) 신경망 모델(Neural Network Model)
```{r}
# 신경망 모델
# 데이터확인

# 정규화
normalization <- function(x) {
  return((x - min(x)) / (max(x) - min(x)))
}

movie_norm <- as.data.frame(lapply(movie, normalization))
summary(movie_norm)

library(neuralnet)

sample_count <- round(nrow(movie)) * 0.75
set.seed(123)
sample_rows <- sample(nrow(movie), sample_count)
# 학습/테스트 데이터 세트
movie_train <- movie_norm[sample_rows, ]
movie_test <- movie_norm[-sample_rows, ]

# 신경망 모델 생성
set.seed(1234)
movie_model <- neuralnet(formula = imdb_score ~ .,
                         data = movie_train)
# 생성된 NN 확인
plot(movie_model)

# 만들어진 NN 평가
# 테스트 데이터 세트에 적용
model_result <- compute(movie_model, movie_test[-6])

predict_result <- model_result$net.result
# 상관 계수
cor(predict_result, movie_test$imdb_score) # 0.403

# 모델 향상
movie_model5 <- neuralnet(formula = imdb_score ~ .,
                          data = movie_train,
                          hidden = 5)
plot(movie_model5)
```

